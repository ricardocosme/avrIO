** avrIO
C++11/17/20 library to manipulate I/O port pins of AVR8. The purpose of this library is to raise the level of abstraction to operate I/O ports with zero-overhead in mind. It's a header only library that doesn't require any external dependency to be used, the only requirement is ~avr-gcc~ with at least C++11 support. 

**** [[file:demo/led.cpp][demo/led.cpp]]

#+BEGIN_SRC C++
#include <avr/io.hpp>

using namespace avr::io;

int main() {
    Pb0 led{output};
    Pb3 sw{pullup};

    while(true) led.high(sw.is_low());
}
#+END_SRC

The [[https://github.com/ricardocosme/avrIO][avrIO]] handles what is the type of the microcontroller to know what is the pin in the chip that is represented by ~avr::io::Pb0~ or ~avr::io::Pb3~ (see [[file:include/avr/io/io.hpp][include/avr/io/io.hpp]]). 

**** [[file:demo/c++20/api.cpp][demo/c++20/api.cpp]]

#+BEGIN_SRC C++
#include <avr/io.hpp>

using namespace avr::io;

template<avr::io::Pin Pin>
struct led_t {
    Pin pin;
    led_t(Pin ppin) : pin(ppin) { out(pin); };
    void on(bool v = true) { high(pin, v); }
};

int main() {
    led_t led{pb0};
    Pb3 sw{pullup};
    
    while(true) led.on(sw.is_low());
}
#+END_SRC

The version above has support to C++20 Concepts and the template parameter of the class template ~led~ is implicitly deducted. There is a version [[file:demo/api.cpp][demo/api.cpp]] with support to C++11. 

This library can help the designer to offer an API that needs to handle pins. It can receive the information using a flexible and minimal representation. The argument ~Pin~ can be anything that models the concept ~avr::io::Pin~ and only one object can represent the location of the pin. There is no need, for example, to ask for the registers that are related to the pin in question.

Above we are using the API ~dev::led~ using a global object ~avr::io::pb0~ which is an instance of the model ~avr::io::pxn~ that modes the concept ~avr::io::Pin~. Note that we can also instantiate the abstraction with something more verbose like ~dev::led led{Pb0{}}~ , but in this case this doesn't make sense because all we want is to receive the pin without any initialization about your mode of operation, like if the pin is operating as an input or output one. The implementation of the API is using free functions like ~high(pin)~ instead of ~pin.high()~ because the model can't always be a class, it can be for example an integer, like that ones that are used by ~avr-libc~ through macros of the type ~PXN~. 

*** Basic functions
A basic set of functions is offered in order to allow some basic operations on port pins. /Note, the syntax below uses C++20 to better express the prototype of the function, but all functions has support to C++11 or greater. The purpose here is only to show briefly what each function do. Open [[file:include/avr/io/functions.hpp][avr/io/functions.hpp]] to see the real prototype./

**** ~uint8_t pin_number(auto Pin)~
Returns the bit number of the pin. This is the nunmber ~n~ in the general form ~Pxn~.

**** ~volatile uint8_t& portx(auto Pin)~
Returns the memory address of the register ~PORTx~.

**** ~volatile uint8_t& ddrx(auto Pin)~
Returns the memory address of the register ~DDRx~.

**** ~volatile uint8_t& pinx(auto Pin)~
Returns the memory address of the register ~PINx~.

**** ~void low(auto Pin, bool v = true)~
If the pin is configured as an output pin then it drives low(zero) if ~v~ is true or it drives high(one) if ~v~ is false, otherwise the internal pull-up resistor is disabled if ~v~ is true or enabled if ~v~ is false.

**** ~void high(auto Pin, bool v = true)~
If the pin is configured as an output pin then it drives high(one) if ~v~ is true or it drives low(zero) if ~v~ is false, otherwise the internal pull-up resistor is enabled if ~v~ is true or disabled if ~v~ is false.

**** ~void toggle(auto Pin)~
Toggles the pin value. If the pin state is equal to high then it will be equal to low, otherwise, if the pin state is equal to low then it will be equal to high.

**** ~void out(auto Pin)~ 
Configures the pin as an output pin.

**** ~void in(auto Pin)~ 
Configures the pin as an input pin without the pull-up resistor.

**** ~void in(auto Pin, pullup_t)~
Configures the pin as an input pin with pull-up resistor activated.

**** ~is_high(auto Pin)~
Returns true if the pin state is high(=1).

**** ~is_low(auto Pin)~
Returns true if the pin state is low(=0).

*** [Optional&Advanced] Adaptability to other abstractions
Other models to the concept ~avr::io::Pin~ can be written to adapt an existing abstraction that represents port I/O pins to components written using ~avrIO~. For example, an API can be called with the instance ~avr::io::pc1~ but it also can be called with another abstraction that is already used in the project of the user to represent a pin, like integers that represents the pins of the chip in a specific board(like Arduino Micro) or pins related to a specific package type(like PDIP) of the chip. In order to allow this, the user of the API should extend the ~avrIO~ only once to adapt the desired abstraction to the concept ~avr::io::Pin~. Below is a hypothetical demo of a program that must use an API written in ~avrIO~ but using an interger that represents the pin of an ATtiny85 in the PDIP package form:
#+BEGIN_SRC C++
#include <avr/io.hpp>

#if !(defined(__AVR_ATtiny85__) || defined(__AVR_ATtiny13A__))
#error "This demo is only supported to ATtiny85/13A"
#endif

// This demo shows a hypothetical extension to model the ATtiny85 port
// I/O pins using the numbers of the pins in PDIP package. There isn't
// any intention here to claim that this particular usage is a good
// ideia, the only purpose here is to show how flexible is the
// extension mechanism using a fundamental type as 'int' as a
// representation to a pin.
//
// We want to map the following:
// 1 -> PB5
// 2 -> PB3
// 3 -> PB4
// 5 -> PB0
// 6 -> PB1
// 7 -> PB2
//
template<>
struct avr::io::traits::pin<int> {
    static const uint8_t pin_addr{0x16 + 0x20};
    
    //precondition: (n >= 1 && n <= 3) || (n >= 5 && n <= 7)
    [[gnu::always_inline]]
    auto number(uint8_t n) const {
        if (n >= 5 && n <= 7) return n - 5;
        else if (n >= 2 && n <= 3) return n + 1;
        return 5;
    }
    [[gnu::always_inline]]
    auto pinx(int o) const
    { return reinterpret_cast<volatile uint8_t*>(pin_addr); }
    [[gnu::always_inline]]
    auto ddrx(int o) const
    { return pinx(o) + 1; }
    [[gnu::always_inline]]
    auto portx(int o) const
    { return pinx(o) + 2; }
};

using namespace avr::io;

template<avr::io::Pin Pin>
struct led_t {
    Pin pin;
    led_t(Pin ppin) : pin(ppin) { out(pin); };
    void on(bool v = true) { high(pin, v); }
};

int main() {
    led_t led{5};
    in(2, pullup);

    while(true) led.on(is_low(2));
}
#+END_SRC C++
[[file:demo/c++20/extension.cpp][demo/c++20/extension.cpp]]

In the end, the designer can write an API that not only works with ~avr::io::pxn~ but also with any other model of the concept ~avr::io::Pin~. /Note, C++20 Concepts is not required here in order to allow other models./

*** Performance
The goal here is to compare the code generated using [[https://github.com/ricardocosme/avrIO][avrIO]] with a reference code that doesn't use any expressive abstration, like the one that uses ~sbi~ or ~cbi~ instructions.

Builds using ~avr-gcc 10.2 -mmcu=attiny85 -Os~.

**** demo/led.cpp [-std=c++11] 
#+BEGIN_SRC
00000022 <main>:
  22:	c0 98       	cbi	0x18, 0	; 24
  24:	b8 9a       	sbi	0x17, 0	; 23
  26:	bb 98       	cbi	0x17, 3	; 23
  28:	c3 9a       	sbi	0x18, 3	; 24
  2a:	b3 99       	sbic	0x16, 3	; 22
  2c:	02 c0       	rjmp	.+4      	; 0x32 <main+0x10>
  2e:	c0 9a       	sbi	0x18, 0	; 24
  30:	fc cf       	rjmp	.-8      	; 0x2a <main+0x8>
  32:	c0 98       	cbi	0x18, 0	; 24
  34:	fa cf       	rjmp	.-12     	; 0x2a <main+0x8>
#+END_SRC

**** demo/c++20/api.cpp  [-std=c++20] 
#+BEGIN_SRC
00000022 <main>:
  22:	b8 9a       	sbi	0x17, 0	; 23
  24:	bb 98       	cbi	0x17, 3	; 23
  26:	c3 9a       	sbi	0x18, 3	; 24
  28:	b3 99       	sbic	0x16, 3	; 22
  2a:	02 c0       	rjmp	.+4      	; 0x30 <main+0xe>
  2c:	c0 9a       	sbi	0x18, 0	; 24
  2e:	fc cf       	rjmp	.-8      	; 0x28 <main+0x6>
  30:	c0 98       	cbi	0x18, 0	; 24
  32:	fa cf       	rjmp	.-12     	; 0x28 <main+0x6>
#+END_SRC

**** demo/c++20/extension.cpp  [-std=c++20] 
#+BEGIN_SRC
00000030 <main>:
  30:	b8 9a       	sbi	0x17, 0	; 23
  32:	bb 98       	cbi	0x17, 3	; 23
  34:	c3 9a       	sbi	0x18, 3	; 24
  36:	b3 99       	sbic	0x16, 3	; 22
  38:	02 c0       	rjmp	.+4      	; 0x3e <__SP_H__>
  3a:	c0 9a       	sbi	0x18, 0	; 24
  3c:	fc cf       	rjmp	.-8      	; 0x36 <main+0x6>
  3e:	c0 98       	cbi	0x18, 0	; 24
  40:	fa cf       	rjmp	.-12     	; 0x36 <main+0x6>
#+END_SRC

*** How to use it?
This is a header only library that doesn't require any external dependency to work. It should be enough add the path to the ~include~ directory to your project:
1. Check the requirements section.
2. Add the ~include~ directory to your include path.
3. Add ~#include <avr/io.hpp>~ to your source and enjoy it!

*** How to build the demos?
1. If you want to build the demos with support to C++11, then go to the directory ~demo~, if you want C++20 then go to ~demo/c++20~.
2. Adjust at least the variables ~MCU_TARGET~ and ~AVRDUDE_DEVICE~ in the ~Makefile~ to the appropriate values related to your microcontroller. /Note, the demos are already ready to ATtiny85./
3. ~make~

**** I'm still lost, Is there something simpler than that?
Yes, go to the directory ~demo~ and execute the following minimal command:

~avr-g++ -std=c++11 -Os -mmcu=attiny85 -I../include led.cpp~

The command above should generate a binary ~a.out~ in the current directory. Note, you should replace the argument ~attiny85~ to the approriate value related to your microcontroller.

*** Suppoted microcontrollers
1. ATtiny13A/85
2. ATmega328P

*** Requirements
1. ~avr-gcc~ with at least ~-std=c++11~ (Tests with ~avr-gcc 10.2~)
3. [optional @ C++20] If the freestanding implementation of ~libstdc++~ is used, the concepts defined by the library are better defined because of the functions provided by the header ~<concepts>~.

*** Projects using the library
**** [[https://github.com/ricardocosme/hx711][hx711]]

*** Contributions
This work is under heavily development and all type of contributions are very welcome. If you like what you see and you have interest to help, don't hesitate to open a pull request or issue.
