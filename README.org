** avrIO
C++11/17/20 components to manipulate the I/O ports of AVR-8. The purpose of this library is to raise the level of abstraction to operate I/O ports with zero-overhead in mind. It's a header only library that doesn't require any external dependency to be used, the only requirement is ~avr-gcc~ with at least C++11 support. 

At the moment the work is focused in the pins of the ports and only a few microcontrollers are supported. The work is under heavily development and all type of contributions are very welcome. If you like what you see and you have interest to help, don't hesitate to open a pull request or issue.

*** Demos

**** [[file:demo/led.cpp][demo/led.cpp]]

#+BEGIN_SRC C++
#include <avr/io/io.hpp>

using namespace avr::io;

int main() {
    Pb0 led{mode::output};
    Pb3 push_btn{mode::pullup};
    
    while(true)
        led.high(!push_btn.is_high());
}
#+END_SRC

The [[https://github.com/ricardocosme/avrIO][avrIO]] handles what is the type of the microcontroller to know what is the pin in the chip that is represented by ~avr::io::Pb0~ or ~avr::io::Pb3~. (see [[file:include/avr/io/io.hpp][include/avr/io/io.hpp]])

**** [[file:demo/api.cpp][demo/api.cpp]]

#+BEGIN_SRC C++
#include <avr/io/io.hpp>

using namespace avr::io;

namespace dev {
template<typename Pin>
struct led {
    const Pin pin;
    led(Pin ppin) : pin(ppin) { out(pin); };
    void on(bool v = true) { high(pin, v); }
};
} //namespace dev

int main() {
    dev::led led{pb0};
    Pb3 push_btn{mode::pullup};
    
    while(true)
        led.on(!push_btn.is_high());
}
#+END_SRC

APIs can be written accepting pins without worries about the model which is used. The only requirement is that the type of the pin must be a model of the the concept ~avr::io::Pin~. Above we are using the API ~dev::led~ using a global object ~avr::io::pb0~ which is an instance of the model ~avr::io::pxn~. Note that we can also instantiate the abstraction with something more verbose like ~dev::led led{Pb0{}}~ ,and , the implementation of the API is using free functions like ~high(pin)~ instead of ~pin.high()~ because the model can't always be a class, it can be for example an integer, like that ones that are used by ~avr-libc~ through macros of the type ~PXN~. 

*** Supporting different microcontrollers and environments with the same API
When writing an API it's enough to accept only one object of type ~pxn~ (for example the ~pb0~ or ~pd7~ to represent a pin. This single object knows what is the number of the pin(~n~ in the format ~Pxn~ or ~PORTxn~) as also the memory addresses(PINx, DDRx and PORTxn) that are needed to operate the pin. For example, a constructor to instantiate an abstraction that represents a temperature sensor can be written as:
#+BEGIN_SRC C++
//C++11/17
template<typename Data>
struct sensor {
    sensor(Data pin) { /*...*/ }
};
#+END_SRC

If C++20 is available, concepts can be used to improve error messages as well as the readability of the code:
#+BEGIN_SRC C++
//C++20
template<avr::io::Pin Data>
struct sensor {
    sensor(Data pin) { /*...*/ }
};
#+END_SRC C++

*** Adaptability to other abstractions
Other models to the concept ~avr::io::Pin~ can be written to adapt an existing abstraction that represents port I/O pins to components written with support to ~avrIO~. For example, an API that expects instances of the model to ~avr::io::Pin~ which is shipped with ~avrIO~ (see [[file:include/avr/io/pxn.hpp][avr::io::pxn]]) can be called with another abstraction that is already used in the project of the user, like integers that represents the pins of the chip in a specific board(like Arduino Micro) or pins related to a specific package type(like PDIP) of the chip. Below is a hypothetical demo:
#+BEGIN_SRC C++
//C++11
namespace avr::io::traits{
template<>
struct pin<int> {
    static const uint8_t pin_addr{0x16 + 0x20};
    
    //precondition: (n >= 1 && n <= 3) || (n >= 5 && n <= 7)
    uint8_t number(uint8_t n) const {
        if (n >= 5 && n <= 7) return n - 5;
        else if (n >= 2 && n <= 3) return n + 1;
        return 5;
    }
    volatile uint8_t* pinx(int o) const
    { return reinterpret_cast<volatile uint8_t*>(pin_addr); }
    volatile uint8_t* ddrx(int o) const
    { return reinterpret_cast<volatile uint8_t*>(pin_addr + 1); }
    volatile uint8_t* portx(int o) const
    { return reinterpret_cast<volatile uint8_t*>(pin_addr + 2); }
};
}

template<typename Pin>
void pulse(Pin pin) {
    using namespace avr::io;
    high(pin);
    low(pin);
}

//ATtiny85 PDIP
pulse(7); // the pin 7 in the pin configuration to PDIP is equivalent to PB2
#+END_SRC C++
[[file:demo/extension.cpp][demo/extension.cpp]]

In the end, the designer can write an API that not only works with ~avr::io::pxn~ but also with any other model of the concept ~avr::io::Pin~. /Note, C++20 Concepts is not required here in order to allow other models./

Below are the microcontrollers that are supported at the moment but it should be easy to support others:
1. ATmega328P
2. ATtiny85/13A

*** Performance
The goal here is to compare the code generated using [[https://github.com/ricardocosme/avrIO][avrIO]] with a reference code that doesn't use any expressive abstration, like the one that uses ~sbi~ or ~cbi~ instructions.

Builds using ~avr-gcc 10.2 -std=c++20 -mmcu=attiny85 -Os~.

**** demo/led.cpp
#+BEGIN_SRC
00000030 <main>:
  30:	c0 98       	cbi	0x18, 0	; 24
  32:	b8 9a       	sbi	0x17, 0	; 23
  34:	bb 98       	cbi	0x17, 3	; 23
  36:	c3 9a       	sbi	0x18, 3	; 24
  38:	b3 99       	sbic	0x16, 3	; 22
  3a:	02 c0       	rjmp	.+4      	; 0x40 <__SREG__+0x1>
  3c:	c0 9a       	sbi	0x18, 0	; 24
  3e:	fc cf       	rjmp	.-8      	; 0x38 <main+0x8>
  40:	c0 98       	cbi	0x18, 0	; 24
  42:	fa cf       	rjmp	.-12     	; 0x38 <main+0x8>
#+END_SRC

**** demo/api.cpp
#+BEGIN_SRC
  30:	b8 9a       	sbi	0x17, 0	; 23
  32:	bb 98       	cbi	0x17, 3	; 23
  34:	c3 9a       	sbi	0x18, 3	; 24
  36:	b3 99       	sbic	0x16, 3	; 22
  38:	02 c0       	rjmp	.+4      	; 0x3e <__SP_H__>
  3a:	c0 9a       	sbi	0x18, 0	; 24
  3c:	fc cf       	rjmp	.-8      	; 0x36 <main+0x6>
  3e:	c0 98       	cbi	0x18, 0	; 24
  40:	fa cf       	rjmp	.-12     	; 0x36 <main+0x6>
#+END_SRC

**** demo/extension.cpp
#+BEGIN_SRC
00000030 <main>:
  30:	c2 9a       	sbi	0x18, 2	; 24
  32:	c2 98       	cbi	0x18, 2	; 24
  34:	90 e0       	ldi	r25, 0x00	; 0
  36:	80 e0       	ldi	r24, 0x00	; 0
  38:	08 95       	ret
#+END_SRC

*** Requires
1. ~avr-gcc~ with at least ~-std=c++11~ (Tests with ~avr-gcc 10.2~)
2. [optional @ C++20] If the freestanding implementation of ~libstdc++~ is used, the concepts defined by the library are better defined because of the functions provided by the header ~<concepts>~.

*** Projects using the library
**** [[https://github.com/ricardocosme/hx711][hx711]]

